import{_ as i,c as o,f as e,a as n,b as a,d as t,e as p,r as c,o as d}from"./app-CB8GcC1F.js";const r={};function u(m,s){const l=c("RouteLink");return d(),o("div",null,[s[9]||(s[9]=e('<h1 id="具体问题列表" tabindex="-1"><a class="header-anchor" href="#具体问题列表"><span>具体问题列表</span></a></h1><h2 id="_1-流量上涨导致系统响应缓慢" tabindex="-1"><a class="header-anchor" href="#_1-流量上涨导致系统响应缓慢"><span>1.流量上涨导致系统响应缓慢</span></a></h2><h3 id="_1-1-问题及背景" tabindex="-1"><a class="header-anchor" href="#_1-1-问题及背景"><span>1.1 问题及背景</span></a></h3><p>小公司小项目，经过运营同事的努力，流量缓慢上涨，突然有一天，大量客户反馈系统很慢很卡，于是对后端Java系统进行排查。</p><blockquote><p>话说前头，这种情况其实直接加钱升级服务器，升级数据库，服务器扩容，完全可以解决。但还是尽量尝试找一下解决的办法，对项目和程序员都有好处。</p></blockquote><h3 id="_1-2-解决过程记录" tabindex="-1"><a class="header-anchor" href="#_1-2-解决过程记录"><span>1.2 解决过程记录</span></a></h3>',6)),n("ol",null,[s[6]||(s[6]=n("li",null,[n("p",null,"给系统加上统一的接口入参打印和耗时打印日志，收集到SLS（阿里云的日志收集服务），找到耗时比较高的接口。")],-1)),n("li",null,[n("p",null,[s[1]||(s[1]=a("通过Arthas定位到接口耗时的比较高的方法。参阅")),t(l,{to:"/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/%E6%8E%A5%E5%8F%A3%E8%80%97%E6%97%B6%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.html"},{default:p(()=>s[0]||(s[0]=[a("接口耗时问题排查")])),_:1}),s[2]||(s[2]=a("。"))])]),s[7]||(s[7]=n("li",null,[n("p",null,[a("发现是从"),n("code",null,"Redis"),a("中获取数据时的遇到的问题，但是在阿里云"),n("code",null,"Redis"),a("控制台又没看到慢日志的打印，此时慢日志的参数设置是默认值"),n("code",null,"slowlog-log-slower-than=20000(20ms)"),a("。猜测是网络问题。")])],-1)),n("li",null,[n("p",null,[s[4]||(s[4]=a("接着排查服务器中网络的问题。参阅")),t(l,{to:"/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.html"},{default:p(()=>s[3]||(s[3]=[a("网络连接相关问题排查")])),_:1}),s[5]||(s[5]=a("。"))])]),s[8]||(s[8]=e(`<li><p>发现当请求量大的时候，Java进程产生了大量的<code>TIME_WAIT</code>（大概是四五千个），处于<code>ESTABLISHED</code>状态的才几百个，感觉不对劲。于是找到<code>TIME_WAIT</code>与之对应的远程ip均来自同一网段，猜测应该是来自于阿里云的<code>CLB(负载均衡服务)</code>集群。猜测应该是<code>CLB集群</code>和<code>Java服务</code>之间没有复用连接。</p></li><li><p>检查<code>Java服务</code>的配置文件，使用<code>Spring Boot</code>的<code>tomcat</code>，项目配置如下：</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token key atrule">server</span><span class="token punctuation">:</span></span>
<span class="line">	<span class="token key atrule">tomcat</span><span class="token punctuation">:</span></span>
<span class="line">		<span class="token key atrule">keep-alive-timeout</span><span class="token punctuation">:</span> <span class="token number">15000</span></span>
<span class="line">		<span class="token key atrule">connection-timeout</span><span class="token punctuation">:</span> <span class="token number">15000</span></span>
<span class="line">		<span class="token key atrule">max-keep-alive-requests</span><span class="token punctuation">:</span> <span class="token number">100</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以发现<code>Java服务</code>是配置了<code>keep-alive</code>的，但是依旧产生了<code>TIME_WAIT</code>。然后</p></li><li><p>想到<code>TIME_WAIT</code>是来自于主动关闭连接的一方，于是猜测可能前端在<code>请求头</code>中加上了<code>Connection: close</code>参数，于是将前端请求头打印在统一日志中，在<code>SLS</code>中看到，确实<code>Java服务</code>收到的请求中，请求头都是带<code>Connection: close</code>。</p></li><li><p>怀疑是<code>CLB</code>的配置不对，于是在<code>CLB</code>控制台查找，并翻阅官方文档，发现并没有相关配置可以控制。</p></li><li><p>询问前端同事，前端使用的是<code>HTTP/2.0</code>的库，又检查后端配置文件，发现没有启用<code>HTTP/2.0</code>，于是修改配置文件如下：</p></li>`,5))]),s[10]||(s[10]=e(`<div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token key atrule">server</span><span class="token punctuation">:</span></span>
<span class="line">	<span class="token key atrule">http2</span><span class="token punctuation">:</span></span>
<span class="line">		<span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>改之<code>前</code> 通过<code>curl</code>发起测试请求，请求及响应如下：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># curl请求如下</span></span>
<span class="line"><span class="token function">curl</span> <span class="token parameter variable">--location</span> <span class="token parameter variable">--request</span> GET <span class="token string">&#39;http://your_ip:your_port/your_end_point&#39;</span> <span class="token punctuation">\\</span></span>
<span class="line"><span class="token parameter variable">--header</span> <span class="token string">&#39;Content-Type: application/json&#39;</span> <span class="token punctuation">\\</span></span>
<span class="line">--data-raw <span class="token string">&#39;{</span>
<span class="line">    &quot;your_field&quot;: &quot;your_value&quot;</span>
<span class="line">}&#39;</span> <span class="token punctuation">\\</span></span>
<span class="line"><span class="token parameter variable">--http2</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 响应正常，此处不展示</span></span>
<span class="line"><span class="token comment"># 日志输出如下：</span></span>
<span class="line"><span class="token punctuation">{</span><span class="token string">&quot;protocol&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;HTTP/1.1&quot;</span>,<span class="token string">&quot;connection&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;Upgrade, HTTP2-Settings&quot;</span><span class="token punctuation">}</span></span>
<span class="line"><span class="token comment"># 可见依旧使用 HTTP/1.1 的请求</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>改之<code>后</code> 通过同样<code>curl</code>发起测试请求，请求及响应如下：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># curl请求如下</span></span>
<span class="line"><span class="token function">curl</span> <span class="token parameter variable">--location</span> <span class="token parameter variable">--request</span> GET <span class="token string">&#39;http://your_ip:your_port/your_end_point&#39;</span> <span class="token punctuation">\\</span></span>
<span class="line"><span class="token parameter variable">--header</span> <span class="token string">&#39;Content-Type: application/json&#39;</span> <span class="token punctuation">\\</span></span>
<span class="line">--data-raw <span class="token string">&#39;{</span>
<span class="line">    &quot;your_field&quot;: &quot;your_value&quot;</span>
<span class="line">}&#39;</span> <span class="token punctuation">\\</span></span>
<span class="line"><span class="token parameter variable">--http2</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 响应正常，此处不展示</span></span>
<span class="line"><span class="token comment"># 日志输出如下：</span></span>
<span class="line"><span class="token punctuation">{</span><span class="token string">&quot;protocol&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;HTTP/2.0&quot;</span>,<span class="token string">&quot;connection&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;Upgrade, HTTP2-Settings&quot;</span><span class="token punctuation">}</span></span>
<span class="line"><span class="token comment"># 可成功使用 HTTP/2.0 的请求</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>经过测试，不影响其他接口，后端发版上线。</p><ol start="10"><li><p>上线后查看日志，发现请求头输出依旧如下，问题没有得到解决。</p><div class="language-json line-numbers-mode" data-highlighter="prismjs" data-ext="json" data-title="json"><pre><code><span class="line"><span class="token punctuation">{</span><span class="token property">&quot;protocol&quot;</span><span class="token operator">:</span><span class="token string">&quot;HTTP/1.1&quot;</span><span class="token punctuation">,</span><span class="token property">&quot;connection&quot;</span><span class="token operator">:</span><span class="token string">&quot;close&quot;</span><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>再次找到前端同事，前端同事排查，发现前端使用的请求框架有问题，交给前端同事处理便没了下文（因为大家都忙，暂时选择加机器解决）。</p></li><li><p>转头一想：</p><ol><li>上述案例中，客户端请求打到负载均衡，确实也没有必要设置<code>keep-alive</code>，但是负载均衡和后端服务器之间，应该是要复用连接的，但是没有办法配置<code>CLB</code>，所以这条路也没有办法走下去，除非自建<code>Nginx集群</code>，但当时用云服务，就是为了图方便省事，并且小公司目前也没有那么多时间精力和人力去做基建，遂暂时搁置。</li><li>前端的请求，是不是经过<code>CLB</code>转发之后，从<code>HTTP/2.0</code>变成了<code>HTTP/1.1</code>呢？后续经过本地联调， 发现不是<code>CLB</code>的问题，所以又只能搁置，毕竟不在我的控制范围内了。</li><li>问过<code>GPT</code>后，其说在并发大的系统中，存在大量的<code>TIME_WAIT</code>也很正常，也不至于导致请求一个<code>Redis</code>要好几秒，查看<code>Redis</code>的控制台监控，那时连接数也才三四百，<code>CPU利用率</code>也才<code>5%</code>，<code>Redis内存利用率</code>也只有百分之几，于是猜测可能是项目的配置上有问题。</li></ol></li><li><p>后面抽时间对项目的Redis配置又进行了一番调参测试和debug，确实发现一些问题，先留坑，后面空了再写。</p></li></ol>`,7))])}const k=i(r,[["render",u],["__file","具体问题列表.html.vue"]]),E=JSON.parse('{"path":"/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/%E5%85%B7%E4%BD%93%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8.html","title":"具体问题列表","lang":"zh-CN","frontmatter":{"title":"具体问题列表","date":"2024-12-28T14:46:37.000Z"},"headers":[{"level":2,"title":"1.流量上涨导致系统响应缓慢","slug":"_1-流量上涨导致系统响应缓慢","link":"#_1-流量上涨导致系统响应缓慢","children":[{"level":3,"title":"1.1 问题及背景","slug":"_1-1-问题及背景","link":"#_1-1-问题及背景","children":[]},{"level":3,"title":"1.2 解决过程记录","slug":"_1-2-解决过程记录","link":"#_1-2-解决过程记录","children":[]}]}],"git":{"updatedTime":1735376738000},"filePathRelative":"工作中遇到的问题及排查方法/具体问题列表.md"}');export{k as comp,E as data};
